// This was generated by project/codegen/engine_gen.cpp
#pragma once
#if INTELLISENSE_DIRECTIVES
#include "engine_module.hpp"
#include "platform.hpp"
#endif

struct Vec2_f32
{
	union
	{
		struct
		{
			f32 x;
			f32 y;
		};

		f32 Basis[ 2 ];
	};
};

template<>
constexpr Vec2_f32 tmpl_zero< Vec2_f32 >()
{
	return { 0, 0 };
}

inline Vec2_f32 abs( Vec2_f32 v )
{
	Vec2_f32 result { abs( v.x ), abs( v.y ) };
	return result;
}

inline f32 magnitude( Vec2_f32 v )
{
	f32 result = sqrt( v.x * v.x + v.y * v.y );
	return result;
}

inline Vec2_f32 normalize( Vec2_f32 v )
{
	f32 square_size = v.x * v.x + v.y * v.y;
	if ( square_size < scast( f32, 1e-4 ) )
	{
		return Zero( Vec2_f32 );
	}
	f32      mag = sqrt( square_size );
	Vec2_f32 result { v.x / mag, v.y / mag };
	return result;
}

inline Vec2_f32 operator-( Vec2_f32 v )
{
	Vec2_f32 result { -v.x, -v.y };
	return result;
}

inline Vec2_f32 operator+( Vec2_f32 a, Vec2_f32 b )
{
	Vec2_f32 result { a.x + b.x, a.y + b.y };
	return result;
}

inline Vec2_f32 operator-( Vec2_f32 a, Vec2_f32 b )
{
	Vec2_f32 result { a.x - b.x, a.y - b.y };
	return result;
}

inline Vec2_f32 operator*( Vec2_f32 v, f32 s )
{
	Vec2_f32 result { v.x * s, v.y * s };
	return result;
}

inline Vec2_f32 operator*( f32 s, Vec2_f32 v )
{
	Vec2_f32 result { v.x * s, v.y * s };
	return result;
}

inline Vec2_f32 operator/( Vec2_f32 v, f32 s )
{
	Vec2_f32 result { v.x / s, v.y / s };
	return result;
}

inline Vec2_f32& operator+=( Vec2_f32& a, Vec2_f32 b )
{
	a.x += b.x;
	a.y += b.y;
	return a;
}

inline Vec2_f32& operator-=( Vec2_f32& a, Vec2_f32 b )
{
	a.x -= b.x;
	a.y -= b.y;
	return a;
}

inline Vec2_f32& operator*=( Vec2_f32& v, f32 s )
{
	v.x *= s;
	v.y *= s;
	return v;
}

inline Vec2_f32& operator/=( Vec2_f32& v, f32 s )
{
	v.x /= s;
	v.y /= s;
	return v;
}

struct Vec2_s32
{
	union
	{
		struct
		{
			s32 x;
			s32 y;
		};

		s32 Basis[ 2 ];
	};
};

template<>
constexpr Vec2_s32 tmpl_zero< Vec2_s32 >()
{
	return { 0, 0 };
}

inline Vec2_s32 abs( Vec2_s32 v )
{
	Vec2_s32 result { abs( v.x ), abs( v.y ) };
	return result;
}

inline s32 magnitude( Vec2_s32 v )
{
	s32 result = sqrt( v.x * v.x + v.y * v.y );
	return result;
}

inline Vec2_s32 normalize( Vec2_s32 v )
{
	s32 square_size = v.x * v.x + v.y * v.y;
	if ( square_size < scast( s32, 1e-4 ) )
	{
		return Zero( Vec2_s32 );
	}
	s32      mag = sqrt( square_size );
	Vec2_s32 result { v.x / mag, v.y / mag };
	return result;
}

inline Vec2_s32 operator-( Vec2_s32 v )
{
	Vec2_s32 result { -v.x, -v.y };
	return result;
}

inline Vec2_s32 operator+( Vec2_s32 a, Vec2_s32 b )
{
	Vec2_s32 result { a.x + b.x, a.y + b.y };
	return result;
}

inline Vec2_s32 operator-( Vec2_s32 a, Vec2_s32 b )
{
	Vec2_s32 result { a.x - b.x, a.y - b.y };
	return result;
}

inline Vec2_s32 operator*( Vec2_s32 v, s32 s )
{
	Vec2_s32 result { v.x * s, v.y * s };
	return result;
}

inline Vec2_s32 operator*( s32 s, Vec2_s32 v )
{
	Vec2_s32 result { v.x * s, v.y * s };
	return result;
}

inline Vec2_s32 operator/( Vec2_s32 v, s32 s )
{
	Vec2_s32 result { v.x / s, v.y / s };
	return result;
}

inline Vec2_s32& operator+=( Vec2_s32& a, Vec2_s32 b )
{
	a.x += b.x;
	a.y += b.y;
	return a;
}

inline Vec2_s32& operator-=( Vec2_s32& a, Vec2_s32 b )
{
	a.x -= b.x;
	a.y -= b.y;
	return a;
}

inline Vec2_s32& operator*=( Vec2_s32& v, s32 s )
{
	v.x *= s;
	v.y *= s;
	return v;
}

inline Vec2_s32& operator/=( Vec2_s32& v, s32 s )
{
	v.x /= s;
	v.y /= s;
	return v;
}

using Vec2  = Vec2_f32;
using Vec2i = Vec2_s32;
